<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>aw-watcher-ask</title>
    <style>
        body {
            font-family: sans-serif;
            overflow: hidden;
            margin: 0;
            height: 100vh;
        }

    </style>
</head>
<body>
    Loading...
</body>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@0.1.1"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.5.0/axios.min.js"></script>

<script>
    const exports = {};
    function require(name) {
        if (name === 'axios') {
            return axios;
        }
        throw new Error(`Cannot find module '${name}'`);
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/aw-client@0.3.4/out/aw-client.min.js"></script>

<script defer>
    const urlParams = new URLSearchParams(window.location.search);
    const start = urlParams.get('start');
    const end = urlParams.get('end');
    const hostname = urlParams.get('hostname') || 'localhost.localdomain';

    const client = new AWClient('aw-watcher-ask', { baseURL: window.location.origin });

    function getNiceStep(range) {
        const idealStep = range / 5;
        const magnitude = Math.pow(10, Math.floor(Math.log10(idealStep)));
        const normalized = idealStep / magnitude;
        
        let niceNormalized;
        if (normalized < 1.5) {
            niceNormalized = 1;
        } else if (normalized < 3.5) {
            niceNormalized = 2;
        } else if (normalized < 7.5) {
            niceNormalized = 5;
        } else {
            niceNormalized = 10;
        }
        
        return niceNormalized * magnitude;
    }

    function aggregateByHour(events) {
        const hourMap = new Map();
        
        for (const event of events) {
            const date = new Date(event.timestamp);
            const hourTimestamp = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate(),
                date.getHours()
            ).getTime();
            
        if (!hourMap.has(hourTimestamp)) {
            hourMap.set(hourTimestamp, { sum: 0, count: 0, reasons: new Set() });
        }
        
        const bucket = hourMap.get(hourTimestamp);
        bucket.sum += parseFloat(event.data.value);
        bucket.count += 1;
        
        const reason = event.data.reason?.trim();
        if (reason) {
            const splitReasons = reason.split(',').map(r => r.trim()).filter(r => r);
            splitReasons.forEach(r => bucket.reasons.add(r));
        }
        }
        
        return Array.from(hourMap.entries())
            .map(([timestamp, data]) => ({
                x: new Date(timestamp),
                y: data.sum / data.count,
                reason: data.reasons.size > 0 
                    ? Array.from(data.reasons).map(r => `• ${r}`).join('<br>') 
                    : ''
            }))
            .sort((a, b) => a.x - b.x);
    }

    function aggregateByDay(events) {
        const dayMap = new Map();
        
        for (const event of events) {
            const date = new Date(event.timestamp);
            const dayTimestamp = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate()
            ).getTime();
            
            if (!dayMap.has(dayTimestamp)) {
                dayMap.set(dayTimestamp, { sum: 0, count: 0, reasons: new Set() });
            }
            
            const bucket = dayMap.get(dayTimestamp);
            bucket.sum += parseFloat(event.data.value);
            bucket.count += 1;
            
            const reason = event.data.reason?.trim();
            if (reason) {
                const splitReasons = reason.split(',').map(r => r.trim()).filter(r => r);
                splitReasons.forEach(r => bucket.reasons.add(r));
            }
        }
        
        return Array.from(dayMap.entries())
            .map(([timestamp, data]) => ({
                x: new Date(timestamp),
                y: data.sum / data.count,
                reason: data.reasons.size > 0 
                    ? Array.from(data.reasons).map(r => `• ${r}`).join('<br>') 
                    : ''
            }))
            .sort((a, b) => a.x - b.x);
    }

    function getAggregationConfig(start, end) {
        const duration = new Date(end) - new Date(start);
        if (duration > 24 * 60 * 60 * 1000) {
            return {
                aggregFn: aggregateByDay,
                timeUnit: 'day',
                displayFormat: 'MMM DD'
            };
        }
        return {
            aggregFn: aggregateByHour,
            timeUnit: 'hour',
            displayFormat: 'HH:mm'
        };
    }

    const colors = [
        'rgb(41, 255, 1)',
        'rgb(255, 99, 132)',
        'rgb(54, 162, 235)',
        'rgb(255, 206, 86)',
        'rgb(75, 192, 192)',
        'rgb(153, 102, 255)',
        'rgb(255, 159, 64)',
        'rgb(199, 199, 199)'
    ];

    client.query(
        [`${start}/${end}`],
        [`RETURN = query_bucket("aw-watcher-ask_${hostname}");`]
    ).then((awData) => {
        const events = awData[0];

        if (events.length === 0) {
            document.body.innerHTML = '<p>No events found for the selected time range.</p>';
            return;
        }

        const scaleEvents = events.filter(event => {
            if (event.data.success !== true) return false;
            const value = event.data.value;
            return value !== undefined && value !== null && value !== '' && !isNaN(parseFloat(value));
        });

        if (scaleEvents.length === 0) {
            document.body.innerHTML = '<p>No scale-type responses found.</p>';
            return;
        }

        let minScale = parseFloat(scaleEvents[0].data['min-value']);
        let maxScale = parseFloat(scaleEvents[0].data['max-value']);

        const titles = [...new Set(scaleEvents.map(e => e.data.title))];

        const aggregConfig = getAggregationConfig(start, end);

        const datasets = titles.map((title, index) => {
            const titleEvents = scaleEvents.filter(e => e.data.title === title);
            const aggregatedData = aggregConfig.aggregFn(titleEvents);

            return {
                label: title,
                data: aggregatedData,
                borderColor: colors[index % colors.length],
                backgroundColor: colors[index % colors.length].replace('rgb', 'rgba').replace(')', ', 0.1)'),
                fill: true,
                tension: 0.25
            };
        });

        document.body.removeChild(document.body.firstChild);
        const ctx = document.createElement('canvas');
        document.body.appendChild(ctx);

        new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                scales: {
                    x: {
                        type: 'time',
                        min: new Date(start),
                        max: new Date(end),
                        time: {
                            unit: aggregConfig.timeUnit,
                            displayFormats: {
                                [aggregConfig.timeUnit]: aggregConfig.displayFormat
                            }
                        },
                        ticks: {
                            format: aggregConfig.displayFormat
                        }
                    },
                    y: {
                        min: Math.floor(minScale - (maxScale - minScale) * 0.1),
                        max: Math.ceil(maxScale + (maxScale - minScale) * 0.1),
                        title: {
                            display: true,
                            text: 'Scale Value'
                        },
                        ticks: {
                            stepSize: getNiceStep(
                                Math.ceil(maxScale + (maxScale - minScale) * 0.1) - 
                                Math.floor(minScale - (maxScale - minScale) * 0.1)
                            )
                        }
                    }
                },
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: {
                        mode: 'nearest',
                        intersect: false,
                        callbacks: {
                            afterLabel: function(context) {
                                const point = context.raw;
                                if (point.reason && point.reason.trim()) {
                                    return point.reason.split('<br>');
                                }
                                return '';
                            }
                        }
                    }
                }
            }
        });
    }).catch((err) => {
        document.body.innerText = 'Error: ' + err.message;
        console.error(err);
    });
</script>
</html>
